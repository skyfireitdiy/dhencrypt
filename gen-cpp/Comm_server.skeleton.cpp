// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Comm.h"
#include "auth_types.h"
#include "cryptopp/integer.h"
#include "cryptopp/secblockfwd.h"
#include "dhencrypt.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <sstream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

class CommHandler : virtual public CommIf
{
public:
    CommHandler()
    {
        // Your initialization goes here
    }

    void auth(AuthResp &_return, const AuthReq &req)
    {
        Integer prime(req.token.prime.c_str());
        Integer generator(req.token.generator.c_str());
        Integer public_key(req.token.publicKey.c_str());

        cout << "receive client prime: " << prime << endl;
        cout << "receive client generator: " << generator << endl;
        cout << "receive client public_key: " << public_key << endl;

        _dhe = std::make_unique<DHEncrypt>(DHEncrypt::Token {prime, generator, public_key});
        _dhe->SetRemotePublicKey(public_key);
        auto localPublicKey = _dhe->GetToken()->publicKey;
        secretKey = *_dhe->GetSecretKey();
        cout << "server secretKey: " << secretKey << endl;

        ostringstream so;
        so << localPublicKey;
        _return.publicKey = so.str();
        cout << "server public_key: " << _return.publicKey << endl;
    }

    void sendMsg(std::string &_return, const std::string &msg)
    {
        // Your implementation goes here
        printf("sendMsg\n");
    }

private:
    std::unique_ptr<DHEncrypt> _dhe;
    Integer secretKey;
};

int main(int argc, char **argv)
{
    int port = 9090;
    ::std::shared_ptr<CommHandler> handler(new CommHandler());
    ::std::shared_ptr<TProcessor> processor(new CommProcessor(handler));
    ::std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    ::std::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    ::std::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}
