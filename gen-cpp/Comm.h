/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Comm_H
#define Comm_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "auth_types.h"



#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class CommIf {
 public:
  virtual ~CommIf() {}
  virtual void auth(AuthResp& _return, const AuthReq& req) = 0;
  virtual void sendMsg(std::string& _return, const std::string& msg) = 0;
};

class CommIfFactory {
 public:
  typedef CommIf Handler;

  virtual ~CommIfFactory() {}

  virtual CommIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(CommIf* /* handler */) = 0;
  };

class CommIfSingletonFactory : virtual public CommIfFactory {
 public:
  CommIfSingletonFactory(const ::std::shared_ptr<CommIf>& iface) : iface_(iface) {}
  virtual ~CommIfSingletonFactory() {}

  virtual CommIf* getHandler(const ::apache::thrift::TConnectionInfo&) override {
    return iface_.get();
  }
  virtual void releaseHandler(CommIf* /* handler */) override {}

 protected:
  ::std::shared_ptr<CommIf> iface_;
};

class CommNull : virtual public CommIf {
 public:
  virtual ~CommNull() {}
  void auth(AuthResp& /* _return */, const AuthReq& /* req */) override {
    return;
  }
  void sendMsg(std::string& /* _return */, const std::string& /* msg */) override {
    return;
  }
};

typedef struct _Comm_auth_args__isset {
  _Comm_auth_args__isset() : req(false) {}
  bool req :1;
} _Comm_auth_args__isset;

class Comm_auth_args {
 public:

  Comm_auth_args(const Comm_auth_args&);
  Comm_auth_args& operator=(const Comm_auth_args&);
  Comm_auth_args() noexcept {
  }

  virtual ~Comm_auth_args() noexcept;
  AuthReq req;

  _Comm_auth_args__isset __isset;

  void __set_req(const AuthReq& val);

  bool operator == (const Comm_auth_args & rhs) const
  {
    if (!(req == rhs.req))
      return false;
    return true;
  }
  bool operator != (const Comm_auth_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Comm_auth_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Comm_auth_pargs {
 public:


  virtual ~Comm_auth_pargs() noexcept;
  const AuthReq* req;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Comm_auth_result__isset {
  _Comm_auth_result__isset() : success(false) {}
  bool success :1;
} _Comm_auth_result__isset;

class Comm_auth_result {
 public:

  Comm_auth_result(const Comm_auth_result&);
  Comm_auth_result& operator=(const Comm_auth_result&);
  Comm_auth_result() noexcept {
  }

  virtual ~Comm_auth_result() noexcept;
  AuthResp success;

  _Comm_auth_result__isset __isset;

  void __set_success(const AuthResp& val);

  bool operator == (const Comm_auth_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Comm_auth_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Comm_auth_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Comm_auth_presult__isset {
  _Comm_auth_presult__isset() : success(false) {}
  bool success :1;
} _Comm_auth_presult__isset;

class Comm_auth_presult {
 public:


  virtual ~Comm_auth_presult() noexcept;
  AuthResp* success;

  _Comm_auth_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Comm_sendMsg_args__isset {
  _Comm_sendMsg_args__isset() : msg(false) {}
  bool msg :1;
} _Comm_sendMsg_args__isset;

class Comm_sendMsg_args {
 public:

  Comm_sendMsg_args(const Comm_sendMsg_args&);
  Comm_sendMsg_args& operator=(const Comm_sendMsg_args&);
  Comm_sendMsg_args() noexcept
                    : msg() {
  }

  virtual ~Comm_sendMsg_args() noexcept;
  std::string msg;

  _Comm_sendMsg_args__isset __isset;

  void __set_msg(const std::string& val);

  bool operator == (const Comm_sendMsg_args & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const Comm_sendMsg_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Comm_sendMsg_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Comm_sendMsg_pargs {
 public:


  virtual ~Comm_sendMsg_pargs() noexcept;
  const std::string* msg;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Comm_sendMsg_result__isset {
  _Comm_sendMsg_result__isset() : success(false) {}
  bool success :1;
} _Comm_sendMsg_result__isset;

class Comm_sendMsg_result {
 public:

  Comm_sendMsg_result(const Comm_sendMsg_result&);
  Comm_sendMsg_result& operator=(const Comm_sendMsg_result&);
  Comm_sendMsg_result() noexcept
                      : success() {
  }

  virtual ~Comm_sendMsg_result() noexcept;
  std::string success;

  _Comm_sendMsg_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const Comm_sendMsg_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Comm_sendMsg_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Comm_sendMsg_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Comm_sendMsg_presult__isset {
  _Comm_sendMsg_presult__isset() : success(false) {}
  bool success :1;
} _Comm_sendMsg_presult__isset;

class Comm_sendMsg_presult {
 public:


  virtual ~Comm_sendMsg_presult() noexcept;
  std::string* success;

  _Comm_sendMsg_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class CommClient : virtual public CommIf {
 public:
  CommClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  CommClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void auth(AuthResp& _return, const AuthReq& req) override;
  void send_auth(const AuthReq& req);
  void recv_auth(AuthResp& _return);
  void sendMsg(std::string& _return, const std::string& msg) override;
  void send_sendMsg(const std::string& msg);
  void recv_sendMsg(std::string& _return);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class CommProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<CommIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) override;
 private:
  typedef  void (CommProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_auth(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_sendMsg(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  CommProcessor(::std::shared_ptr<CommIf> iface) :
    iface_(iface) {
    processMap_["auth"] = &CommProcessor::process_auth;
    processMap_["sendMsg"] = &CommProcessor::process_sendMsg;
  }

  virtual ~CommProcessor() {}
};

class CommProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  CommProcessorFactory(const ::std::shared_ptr< CommIfFactory >& handlerFactory) noexcept :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) override;

 protected:
  ::std::shared_ptr< CommIfFactory > handlerFactory_;
};

class CommMultiface : virtual public CommIf {
 public:
  CommMultiface(std::vector<std::shared_ptr<CommIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~CommMultiface() {}
 protected:
  std::vector<std::shared_ptr<CommIf> > ifaces_;
  CommMultiface() {}
  void add(::std::shared_ptr<CommIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void auth(AuthResp& _return, const AuthReq& req) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->auth(_return, req);
    }
    ifaces_[i]->auth(_return, req);
    return;
  }

  void sendMsg(std::string& _return, const std::string& msg) override {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->sendMsg(_return, msg);
    }
    ifaces_[i]->sendMsg(_return, msg);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class CommConcurrentClient : virtual public CommIf {
 public:
  CommConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  CommConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void auth(AuthResp& _return, const AuthReq& req) override;
  int32_t send_auth(const AuthReq& req);
  void recv_auth(AuthResp& _return, const int32_t seqid);
  void sendMsg(std::string& _return, const std::string& msg) override;
  int32_t send_sendMsg(const std::string& msg);
  void recv_sendMsg(std::string& _return, const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr< ::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif



#endif
